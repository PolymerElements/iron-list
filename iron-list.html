<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<dom-module id="iron-list">
  <style>

    :host {
      display: block;
      overflow: auto;
      will-change: transform;
    }

    #items {
      position: relative;
      opacity: 0;
    }

    #items > ::content > * {
      width: 100%;
      box-sizing: border-box;
      position: absolute;
      top: 0;
    }

  </style>
  <template>
    <div id="items">
      <content></content>
    </div>
  </template>
</dom-module>

<script>

(function() {

  var IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
  var IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;

  Polymer({

    is: 'iron-list',

    properties: {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * for the row.  If `sort` is provided, the index will reflect the
       * sorted order (rather than the original array order).
       */
      indexAs: {
        type: String,
        value: 'index'
      }

    },

    observers: [
      '_itemsChanged(items.*)'
    ],

    behaviors: [
      Polymer.Templatizer,
      Polymer.IronResizableBehavior
    ],

    listeners: {
      'iron-resize': 'resizeHandler'
    },

    scrollPosition: 0,
    physicalCount: 20,
    physicalStart: 0,
    physicalEnd: 0,
    physicalSize: 0,
    physicalAverage: 0,
    physicalAverageCount: 0,
    virtualCount: 0,
    virtualStart: 0,

    created: function() {
      if (IOS_TOUCH_SCROLLING) {
        this.style.webkitOverflowScrolling = 'touch';
        this.addEventListener('scroll', function() {
          requestAnimationFrame(function() { this._scrollHandler(); }.bind(this));
        }.bind(this));
      } else {
        this.addEventListener('scroll', this._scrollHandler.bind(this));
      }
    },

    _ensureTemplatized: function() {
      if (!this.ctor) {
        this._userTemplate = Polymer.dom(this).querySelector('template');
        if (this._userTemplate) {
          this.templatize(this._userTemplate);
          this._userTemplate.fire = this.fire;
        } else {
          console.warn('x-list requires a template to be provided in light-dom');
        }
      }
    },

    // Implements extension point from Templatizer mixin
    _getStampedChildren: function() {
      return this.physicalItems;
    },

    // Implements extension point from Templatizer
    // Called as a side effect of a template instance path change, responsible
    // for notifying items.<key-for-instance>.<path> change up to host
    _forwardInstancePath: function(inst, path, value) {
      if (path.indexOf(this.as + '.') === 0) {
        this.notifyPath('items.' + inst.__key__ + '.' +
          path.slice(this.as.length + 1), value);
        return true;
      }
    },

    // Implements extension point from Templatizer mixin
    // Called as side-effect of a host property change, responsible for
    // notifying parent.<prop> path change on each row
    _forwardParentProp: function(prop, value) {
      if (this.physicalItems) {
        this.physicalItems.forEach(function(item) {
          var inst = item._templateInstance;
          inst[prop] = value;
        }, this);
      }
    },

    // Implements extension point from Templatizer
    // Called as side-effect of a host path change, responsible for
    // notifying parent.<path> path change on each row
    _forwardParentPath: function(path, value) {
      if (this.physicalItems) {
        this.physicalItems.forEach(function(item) {
          item._templateInstance.notifyPath(path, value, true);
        }, this);
      }
    },

    // Called as a side effect of a host items.<key>.<path> path change,
    // responsible for notifying item.<path> changes to row for key
    _forwardItemPath: function(path, value) {
      if (this._physicalIndexForKey) {
        var dot = path.indexOf('.');
        var key = path.substring(0, dot < 0 ? path.length : dot);
        var idx = this._physicalIndexForKey[key];
        var row = this.physicalItems[idx];
        if (row) {
          var inst = row._templateInstance;
          if (dot >= 0) {
            path = this.as + '.' + path.substring(dot+1);
            inst.notifyPath(path, value, true);
          } else {
            inst[this.as] = value;
          }
        }
      }
    },

    _itemsChanged: function(change) {
      if (change.path == 'items') {
        this.collection = Polymer.Collection.get(this.items);
        this.virtualCount = this.items ? this.items.length : 0;
        this.virtualStart = 0;
        this.physicalOffset = 0;
        this.physicalItems = this.physicalItems || new Array(this.physicalCount);
        this.physicalSizes = this.physicalSizes || new Array(this.physicalCount);
        this.movingUp = [];
        this._ensureTemplatized();
        for (var i=0; i<this.physicalCount; i++) {
          if (!this.physicalItems[i]) {
            var inst = this.stamp(this.items[i]);
            // First element child is item; Safari doesn't support children[0]
            // on a doc fragment
            var item = this.physicalItems[i] = inst.root.querySelector('*');
            item._templateInstance = inst;
            Polymer.dom(this).appendChild(inst.root);
          }
        }
        this.debounce('refresh', this.refresh);
      } else if (change.path == 'items.splices') {
        this._adjustVirtualIndex(change.value.indexSplices);
        this.debounce('refresh', this.refresh);
      } else {
        var subpath = change.path.slice(6);
        this._forwardItemPath(subpath, change.value);
      }
    },

    _scrollHandler: function() {
      this.refresh();
    },

    _adjustVirtualIndex: function(splices) {
      var totalDelta = 0;
      for (var i=0; i<splices.length; i++) {
        var s = splices[i];
        var idx = s.index;
        // We only need to care about changes happening above the current position
        if (idx >= this.virtualStart) {
          break;
        }
        var delta = Math.max(s.addedCount - s.removed.length, idx - this.virtualStart);
        totalDelta += delta;
        this.physicalStart += delta;
        this.virtualStart += delta;
      }
    },

    refresh: function() {

      if (this.virtualCount) {
        // Determine scroll delta
        var lastScrollPos = this.scrollPosition;
        this.scrollPosition = this.scrollTop;
        var delta = this.scrollPosition - lastScrollPos;

        // Adjust starting index & offset by flipping items from bottom<->top
        if (Math.abs(delta) > Math.max(this.physicalSize, this.physicalAverage * this.physicalCount)) {
          var deltaCount = Math.round(delta / this.physicalAverage);
          this.virtualStart += deltaCount;
          this.virtualStart = Math.min(Math.max(this.virtualStart, 0), this.virtualCount-1);
          this.physicalOffset += delta;
        } else {
          var flipBoundary, flipSize;
          var dir = delta < 0 ? -1 : (delta > 0 ? 1 : 0);
          if (dir > 0) {
            flipBoundary = this.physicalSizes[this.physicalStart];
            flipSize = Math.max(this.scrollPosition - this.physicalOffset - flipBoundary, 0);
            idx = this.physicalStart + this.physicalCount;
          } else if (dir < 0) {
            flipBoundary = this.physicalSize - this.viewportSize - this.physicalSizes[this.physicalEnd];
            flipSize = Math.max(this.physicalOffset + flipBoundary - this.scrollPosition, 0);
            idx = this.physicalEnd + this.physicalCount;
          }
          flipSize = Math.max(flipSize, this.viewportSize - this.physicalSize);
          for (var i=0; i<this.physicalCount-1 && flipSize > 0 &&
            (dir > 0 || this.virtualStart > 0) &&
            (dir < 0 || this.virtualStart < (this.virtualCount - this.physicalCount)); i++) {
            var pidx = idx % this.physicalCount;
            var size = this.physicalSizes[pidx] || this.physicalAverage;
            flipSize -= size;
            if (dir > 0) {
              this.physicalOffset += size;
            } else {
              // When moving up, offset adjusted after measuring
              this.movingUp.push(pidx);
            }
            idx += dir;
            this.virtualStart += dir;
          }
        }
      }

      // Note where the physical items start & stop based on virtual index
      this.physicalStart = this.virtualStart % this.physicalCount;
      this.physicalEnd = (this.physicalStart + this.physicalCount - 1) % this.physicalCount;

      // Update
      this._assignModels();
      // TODO(kschaaf): this rAF should not be needed, but without it Chrome
      // measures incorrectly
      requestAnimationFrame(function() {
        this._updateMetrics();
        this._positionItems();
        this._updateScrollerSize();
        // Prevent flash of unpositioned elements
        this.$.items.style.opacity = 1;
      }.bind(this));
    },

    _iterateItems: function(fn) {
      var pidx, vidx, rtn;
      for (pidx = this.physicalStart, vidx = this.virtualStart; pidx < this.physicalCount; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
      for (pidx = 0; pidx < this.physicalStart; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    },

    _assignModels: function() {
      var pidxForKey = this._physicalIndexForKey = {};
      this._iterateItems(function(pidx, vidx) {
        var el = this.physicalItems[pidx];
        var inst = el._templateInstance;
        var item = this.items && this.items[vidx];
        if (inst[this.as] = item) {
          inst.__key__ = this.collection.getKey(item);
          inst[this.indexAs] = vidx;
          el.removeAttribute('hidden');
          pidxForKey[inst.__key__] = pidx;
        } else {
          inst.__key__ = null;
          el.setAttribute('hidden', '');
        }
      });
    },

    _updateMetrics: function() {
      var total = 0;
      var cnt = 0;
      for (var i=0; i<this.physicalCount; i++) {
        var size = this.physicalSizes[i] = this.physicalItems[i].offsetHeight;
        total += size;
        cnt += size ? 1 : 0;
      }
      this.physicalSize = total;
      this.viewportSize = this.offsetHeight;
      this.physicalAverage = Math.round(
        ((this.physicalAverage * this.physicalAverageCount) + total) /
        (this.physicalAverageCount += cnt));
    },

    _positionItems: function() {
      while (this.movingUp.length) {
        var idx = this.movingUp.pop()
        this.physicalOffset -= this.physicalSizes[idx];
      }
      this._adjustScrollPosition();
      var y = this.physicalOffset;
      this._iterateItems(function(pidx) {
        var item = this.physicalItems[pidx];
        item.style.transform = item.style.webkitTransform =
          'translate3d(0,' + y + 'px,0)';
        item._translateX = 0;
        item._translateY = y;
        y += this.physicalSizes[pidx];
      });
    },

    _adjustScrollPosition: function() {
      if (this.virtualStart === 0 && this.physicalOffset) {
        this.physicalOffset = 0;
        // Juking scroll position during interial scrolling on iOS is no bueno
        if (!IOS_TOUCH_SCROLLING) {
          this._resetScrollPosition(this.scrollPosition + this.physicalOffset);
        }
      }
    },

    _resetScrollPosition: function(pos) {
      this.scrollTop = pos;
      this.scrollPosition = this.scrollTop;
    },

    _updateScrollerSize: function() {
      this.scrollSize = (this.physicalOffset + this.physicalSize +
        Math.max(this.virtualCount - this.physicalCount - this.virtualStart, 0) * this.physicalAverage);
      this.$.items.style.height = this.scrollSize + 'px';
    },

    _getFirstVisibleIndex: function() {
      return this._iterateItems(function(pidx, vidx) {
        var item = this.physicalItems[pidx];
        if (item._translateY >= this.scrollPosition) {
          return vidx;
        }
      });
    },

    scrollToIndex: function(idx) {
      idx = Math.min(Math.max(idx, 0), this.virtualCount-1);
      var firstVis = this._getFirstVisibleIndex();
      if (idx < firstVis || this.scrollPosition < (this.scrollSize - this.viewportSize)) {
        var deltaCount = idx - firstVis;
        var deltaPos = deltaCount * this.physicalAverage;
        this.virtualStart = idx;
        this._resetScrollPosition(this.scrollPosition + deltaPos);
        this.physicalOffset = this.scrollPosition;
        this.refresh();
      }
    },

    resetIndex: function(idx) {
      this.virtualStart = idx;
      this.physicalOffset = idx * this.physicalAverage;
      this._resetScrollPosition(this.physicalOffset);
    },

    resizeHandler: function() {
      if (this.physicalItems) {
        this.resetIndex(this._getFirstVisibleIndex());
        this.refresh();
      }
    }

  });

})();

</script>